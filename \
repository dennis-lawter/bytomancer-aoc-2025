use super::d10s1::*;
use super::solutions::final_answer;

const DAY: u8 = 10;
const SOL: u8 = 2;

// #[derive(Debug)]
// pub struct JMach {
//     pub jolts: Vec<u32>,
//     pub wires: Vec<u32>,
// }
// impl JMach {
//     pub fn from_mach(input: &Machine) -> Self {
//         let mut wires = vec!();
//         let num_lights = input.lights.len();
//         for wire_group in &input.wires {
//             // let mut wire_val = 0;
//             // for wire in wire_group {
//             //     wire_val += 1 << wire;
//             // }
//             // wires.push(wire_val);
//
//             // bad solution...
//             let mut tmp = vec![false;num_lights];
//             for wire in wire_group {
//                 tmp[*wire as usize] = true;
//             }
//             let mut wire_val = 0;
//             for t in tmp {
//                 wire_val = wire_val << 1;
//                 if t {
//                     wire_val += 1;
//                 }
//             }
//             wires.push(wire_val);
//         }
//
//         Self {
//             jolts: input.jolts.clone(),
//             wires,
//         }
//     }
// }

pub async fn solve(submit: bool, example: bool) {
    let input = input(example).await;

    let mut ans = 0;
    for mach in &input {
        // let jmach = JMach::from_mach(mach);
        // let presses = find_jolt_buttons(&jmach);
        let num_jolts = mach.jolts.len();
        let init_state = vec![0u32;num_jolts];
        let init_states = vec![init_state];
        let presses = find_jolt_buttons(&mach, &init_states);
        ans += presses;
    }
    
    final_answer(ans, submit, DAY, SOL).await;
}

pub fn find_jolt_buttons(mach:&Machine, states: &Vec<Vec<u32>>) -> usize {
    assert_ne!(0, states.len());
    // println!("");
    // println!("{states:?}");
    // println!("");
    if states.contains(&mach.jolts) {
        return 0;
    }
    let mut new_states: Vec<Vec<u32>> = Vec::new();
    for state in states {
        for wire in &mach.wires {
            let mut new_state = state.clone();
            for i in wire {
                new_state[*i as usize] += 1;
            }
            //
             let mut valid = true;
            for i in 0..mach.jolts.len() {
                if new_state[i] > mach.jolts[i] {
                    valid = false;
                    break;
                }
            }
            if valid {
                // println!("Adding {new_state:?}");
                new_states.push(new_state);
            }
        }
    }

    find_jolt_buttons(mach, &new_states) + 1
}
// pub fn find_jolt_buttons(jmach:&JMach, states: &[[u32]]) -> usize {
//     if states.contains(&jmach.jolts) {
//         return 0;
//     }
//     let mut new_states: Vec<Vec<u32>> = Vec::new();
//     for state in states {
//         for btn in &simp.wires {
//
//         }
//     }
//     find_simp_buttons(simp, &new_states) + 1
// }
